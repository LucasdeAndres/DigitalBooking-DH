{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function makePromise(environment) {\n      var tasks = environment.scheduler;\n      var emitRejection = initEmitRejection();\n      var objectCreate = Object.create || function (proto) {\n        function Child() {}\n        Child.prototype = proto;\n        return new Child();\n      };\n\n      /**\n       * Create a promise whose fate is determined by resolver\n       * @constructor\n       * @returns {Promise} promise\n       * @name Promise\n       */\n      function Promise(resolver, handler) {\n        this._handler = resolver === Handler ? handler : init(resolver);\n      }\n\n      /**\n       * Run the supplied resolver\n       * @param resolver\n       * @returns {Pending}\n       */\n      function init(resolver) {\n        var handler = new Pending();\n        try {\n          resolver(promiseResolve, promiseReject, promiseNotify);\n        } catch (e) {\n          promiseReject(e);\n        }\n        return handler;\n\n        /**\n         * Transition from pre-resolution state to post-resolution state, notifying\n         * all listeners of the ultimate fulfillment or rejection\n         * @param {*} x resolution value\n         */\n        function promiseResolve(x) {\n          handler.resolve(x);\n        }\n        /**\n         * Reject this promise with reason, which will be used verbatim\n         * @param {Error|*} reason rejection reason, strongly suggested\n         *   to be an Error type\n         */\n        function promiseReject(reason) {\n          handler.reject(reason);\n        }\n\n        /**\n         * @deprecated\n         * Issue a progress event, notifying all progress listeners\n         * @param {*} x progress event payload to pass to all listeners\n         */\n        function promiseNotify(x) {\n          handler.notify(x);\n        }\n      }\n\n      // Creation\n\n      Promise.resolve = resolve;\n      Promise.reject = reject;\n      Promise.never = never;\n      Promise._defer = defer;\n      Promise._handler = getHandler;\n\n      /**\n       * Returns a trusted promise. If x is already a trusted promise, it is\n       * returned, otherwise returns a new trusted Promise which follows x.\n       * @param  {*} x\n       * @return {Promise} promise\n       */\n      function resolve(x) {\n        return isPromise(x) ? x : new Promise(Handler, new Async(getHandler(x)));\n      }\n\n      /**\n       * Return a reject promise with x as its reason (x is used verbatim)\n       * @param {*} x\n       * @returns {Promise} rejected promise\n       */\n      function reject(x) {\n        return new Promise(Handler, new Async(new Rejected(x)));\n      }\n\n      /**\n       * Return a promise that remains pending forever\n       * @returns {Promise} forever-pending promise.\n       */\n      function never() {\n        return foreverPendingPromise; // Should be frozen\n      }\n\n      /**\n       * Creates an internal {promise, resolver} pair\n       * @private\n       * @returns {Promise}\n       */\n      function defer() {\n        return new Promise(Handler, new Pending());\n      }\n\n      // Transformation and flow control\n\n      /**\n       * Transform this promise's fulfillment value, returning a new Promise\n       * for the transformed result.  If the promise cannot be fulfilled, onRejected\n       * is called with the reason.  onProgress *may* be called with updates toward\n       * this promise's fulfillment.\n       * @param {function=} onFulfilled fulfillment handler\n       * @param {function=} onRejected rejection handler\n       * @param {function=} onProgress @deprecated progress handler\n       * @return {Promise} new promise\n       */\n      Promise.prototype.then = function (onFulfilled, onRejected, onProgress) {\n        var parent = this._handler;\n        var state = parent.join().state();\n        if (typeof onFulfilled !== 'function' && state > 0 || typeof onRejected !== 'function' && state < 0) {\n          // Short circuit: value will not change, simply share handler\n          return new this.constructor(Handler, parent);\n        }\n        var p = this._beget();\n        var child = p._handler;\n        parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n        return p;\n      };\n\n      /**\n       * If this promise cannot be fulfilled due to an error, call onRejected to\n       * handle the error. Shortcut for .then(undefined, onRejected)\n       * @param {function?} onRejected\n       * @return {Promise}\n       */\n      Promise.prototype['catch'] = function (onRejected) {\n        return this.then(void 0, onRejected);\n      };\n\n      /**\n       * Creates a new, pending promise of the same type as this promise\n       * @private\n       * @returns {Promise}\n       */\n      Promise.prototype._beget = function () {\n        return begetFrom(this._handler, this.constructor);\n      };\n      function begetFrom(parent, Promise) {\n        var child = new Pending(parent.receiver, parent.join().context);\n        return new Promise(Handler, child);\n      }\n\n      // Array combinators\n\n      Promise.all = all;\n      Promise.race = race;\n      Promise._traverse = traverse;\n\n      /**\n       * Return a promise that will fulfill when all promises in the\n       * input array have fulfilled, or will reject when one of the\n       * promises rejects.\n       * @param {array} promises array of promises\n       * @returns {Promise} promise for array of fulfillment values\n       */\n      function all(promises) {\n        return traverseWith(snd, null, promises);\n      }\n\n      /**\n       * Array<Promise<X>> -> Promise<Array<f(X)>>\n       * @private\n       * @param {function} f function to apply to each promise's value\n       * @param {Array} promises array of promises\n       * @returns {Promise} promise for transformed values\n       */\n      function traverse(f, promises) {\n        return traverseWith(tryCatch2, f, promises);\n      }\n      function traverseWith(tryMap, f, promises) {\n        var handler = typeof f === 'function' ? mapAt : settleAt;\n        var resolver = new Pending();\n        var pending = promises.length >>> 0;\n        var results = new Array(pending);\n        for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n          x = promises[i];\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n          traverseAt(promises, handler, i, x, resolver);\n        }\n        if (pending === 0) {\n          resolver.become(new Fulfilled(results));\n        }\n        return new Promise(Handler, resolver);\n        function mapAt(i, x, resolver) {\n          if (!resolver.resolved) {\n            traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n          }\n        }\n        function settleAt(i, x, resolver) {\n          results[i] = x;\n          if (--pending === 0) {\n            resolver.become(new Fulfilled(results));\n          }\n        }\n      }\n      function traverseAt(promises, handler, i, x, resolver) {\n        if (maybeThenable(x)) {\n          var h = getHandlerMaybeThenable(x);\n          var s = h.state();\n          if (s === 0) {\n            h.fold(handler, i, void 0, resolver);\n          } else if (s > 0) {\n            handler(i, h.value, resolver);\n          } else {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n          }\n        } else {\n          handler(i, x, resolver);\n        }\n      }\n      Promise._visitRemaining = visitRemaining;\n      function visitRemaining(promises, start, handler) {\n        for (var i = start; i < promises.length; ++i) {\n          markAsHandled(getHandler(promises[i]), handler);\n        }\n      }\n      function markAsHandled(h, handler) {\n        if (h === handler) {\n          return;\n        }\n        var s = h.state();\n        if (s === 0) {\n          h.visit(h, void 0, h._unreport);\n        } else if (s < 0) {\n          h._unreport();\n        }\n      }\n\n      /**\n       * Fulfill-reject competitive race. Return a promise that will settle\n       * to the same state as the earliest input promise to settle.\n       *\n       * WARNING: The ES6 Promise spec requires that race()ing an empty array\n       * must return a promise that is pending forever.  This implementation\n       * returns a singleton forever-pending promise, the same singleton that is\n       * returned by Promise.never(), thus can be checked with ===\n       *\n       * @param {array} promises array of promises to race\n       * @returns {Promise} if input is non-empty, a promise that will settle\n       * to the same outcome as the earliest input promise to settle. if empty\n       * is empty, returns a promise that will never settle.\n       */\n      function race(promises) {\n        if (typeof promises !== 'object' || promises === null) {\n          return reject(new TypeError('non-iterable passed to race()'));\n        }\n\n        // Sigh, race([]) is untestable unless we return *something*\n        // that is recognizable without calling .then() on it.\n        return promises.length === 0 ? never() : promises.length === 1 ? resolve(promises[0]) : runRace(promises);\n      }\n      function runRace(promises) {\n        var resolver = new Pending();\n        var i, x, h;\n        for (i = 0; i < promises.length; ++i) {\n          x = promises[i];\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n          h = getHandler(x);\n          if (h.state() !== 0) {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n            break;\n          } else {\n            h.visit(resolver, resolver.resolve, resolver.reject);\n          }\n        }\n        return new Promise(Handler, resolver);\n      }\n\n      // Promise internals\n      // Below this, everything is @private\n\n      /**\n       * Get an appropriate handler for x, without checking for cycles\n       * @param {*} x\n       * @returns {object} handler\n       */\n      function getHandler(x) {\n        if (isPromise(x)) {\n          return x._handler.join();\n        }\n        return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n      }\n\n      /**\n       * Get a handler for thenable x.\n       * NOTE: You must only call this if maybeThenable(x) == true\n       * @param {object|function|Promise} x\n       * @returns {object} handler\n       */\n      function getHandlerMaybeThenable(x) {\n        return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n      }\n\n      /**\n       * Get a handler for potentially untrusted thenable x\n       * @param {*} x\n       * @returns {object} handler\n       */\n      function getHandlerUntrusted(x) {\n        try {\n          var untrustedThen = x.then;\n          return typeof untrustedThen === 'function' ? new Thenable(untrustedThen, x) : new Fulfilled(x);\n        } catch (e) {\n          return new Rejected(e);\n        }\n      }\n\n      /**\n       * Handler for a promise that is pending forever\n       * @constructor\n       */\n      function Handler() {}\n      Handler.prototype.when = Handler.prototype.become = Handler.prototype.notify // deprecated\n      = Handler.prototype.fail = Handler.prototype._unreport = Handler.prototype._report = noop;\n      Handler.prototype._state = 0;\n      Handler.prototype.state = function () {\n        return this._state;\n      };\n\n      /**\n       * Recursively collapse handler chain to find the handler\n       * nearest to the fully resolved value.\n       * @returns {object} handler nearest the fully resolved value\n       */\n      Handler.prototype.join = function () {\n        var h = this;\n        while (h.handler !== void 0) {\n          h = h.handler;\n        }\n        return h;\n      };\n      Handler.prototype.chain = function (to, receiver, fulfilled, rejected, progress) {\n        this.when({\n          resolver: to,\n          receiver: receiver,\n          fulfilled: fulfilled,\n          rejected: rejected,\n          progress: progress\n        });\n      };\n      Handler.prototype.visit = function (receiver, fulfilled, rejected, progress) {\n        this.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n      };\n      Handler.prototype.fold = function (f, z, c, to) {\n        this.when(new Fold(f, z, c, to));\n      };\n\n      /**\n       * Handler that invokes fail() on any handler it becomes\n       * @constructor\n       */\n      function FailIfRejected() {}\n      inherit(Handler, FailIfRejected);\n      FailIfRejected.prototype.become = function (h) {\n        h.fail();\n      };\n      var failIfRejected = new FailIfRejected();\n\n      /**\n       * Handler that manages a queue of consumers waiting on a pending promise\n       * @constructor\n       */\n      function Pending(receiver, inheritedContext) {\n        Promise.createContext(this, inheritedContext);\n        this.consumers = void 0;\n        this.receiver = receiver;\n        this.handler = void 0;\n        this.resolved = false;\n      }\n      inherit(Handler, Pending);\n      Pending.prototype._state = 0;\n      Pending.prototype.resolve = function (x) {\n        this.become(getHandler(x));\n      };\n      Pending.prototype.reject = function (x) {\n        if (this.resolved) {\n          return;\n        }\n        this.become(new Rejected(x));\n      };\n      Pending.prototype.join = function () {\n        if (!this.resolved) {\n          return this;\n        }\n        var h = this;\n        while (h.handler !== void 0) {\n          h = h.handler;\n          if (h === this) {\n            return this.handler = cycle();\n          }\n        }\n        return h;\n      };\n      Pending.prototype.run = function () {\n        var q = this.consumers;\n        var handler = this.handler;\n        this.handler = this.handler.join();\n        this.consumers = void 0;\n        for (var i = 0; i < q.length; ++i) {\n          handler.when(q[i]);\n        }\n      };\n      Pending.prototype.become = function (handler) {\n        if (this.resolved) {\n          return;\n        }\n        this.resolved = true;\n        this.handler = handler;\n        if (this.consumers !== void 0) {\n          tasks.enqueue(this);\n        }\n        if (this.context !== void 0) {\n          handler._report(this.context);\n        }\n      };\n      Pending.prototype.when = function (continuation) {\n        if (this.resolved) {\n          tasks.enqueue(new ContinuationTask(continuation, this.handler));\n        } else {\n          if (this.consumers === void 0) {\n            this.consumers = [continuation];\n          } else {\n            this.consumers.push(continuation);\n          }\n        }\n      };\n\n      /**\n       * @deprecated\n       */\n      Pending.prototype.notify = function (x) {\n        if (!this.resolved) {\n          tasks.enqueue(new ProgressTask(x, this));\n        }\n      };\n      Pending.prototype.fail = function (context) {\n        var c = typeof context === 'undefined' ? this.context : context;\n        this.resolved && this.handler.join().fail(c);\n      };\n      Pending.prototype._report = function (context) {\n        this.resolved && this.handler.join()._report(context);\n      };\n      Pending.prototype._unreport = function () {\n        this.resolved && this.handler.join()._unreport();\n      };\n\n      /**\n       * Wrap another handler and force it into a future stack\n       * @param {object} handler\n       * @constructor\n       */\n      function Async(handler) {\n        this.handler = handler;\n      }\n      inherit(Handler, Async);\n      Async.prototype.when = function (continuation) {\n        tasks.enqueue(new ContinuationTask(continuation, this));\n      };\n      Async.prototype._report = function (context) {\n        this.join()._report(context);\n      };\n      Async.prototype._unreport = function () {\n        this.join()._unreport();\n      };\n\n      /**\n       * Handler that wraps an untrusted thenable and assimilates it in a future stack\n       * @param {function} then\n       * @param {{then: function}} thenable\n       * @constructor\n       */\n      function Thenable(then, thenable) {\n        Pending.call(this);\n        tasks.enqueue(new AssimilateTask(then, thenable, this));\n      }\n      inherit(Pending, Thenable);\n\n      /**\n       * Handler for a fulfilled promise\n       * @param {*} x fulfillment value\n       * @constructor\n       */\n      function Fulfilled(x) {\n        Promise.createContext(this);\n        this.value = x;\n      }\n      inherit(Handler, Fulfilled);\n      Fulfilled.prototype._state = 1;\n      Fulfilled.prototype.fold = function (f, z, c, to) {\n        runContinuation3(f, z, this, c, to);\n      };\n      Fulfilled.prototype.when = function (cont) {\n        runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n      };\n      var errorId = 0;\n\n      /**\n       * Handler for a rejected promise\n       * @param {*} x rejection reason\n       * @constructor\n       */\n      function Rejected(x) {\n        Promise.createContext(this);\n        this.id = ++errorId;\n        this.value = x;\n        this.handled = false;\n        this.reported = false;\n        this._report();\n      }\n      inherit(Handler, Rejected);\n      Rejected.prototype._state = -1;\n      Rejected.prototype.fold = function (f, z, c, to) {\n        to.become(this);\n      };\n      Rejected.prototype.when = function (cont) {\n        if (typeof cont.rejected === 'function') {\n          this._unreport();\n        }\n        runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n      };\n      Rejected.prototype._report = function (context) {\n        tasks.afterQueue(new ReportTask(this, context));\n      };\n      Rejected.prototype._unreport = function () {\n        if (this.handled) {\n          return;\n        }\n        this.handled = true;\n        tasks.afterQueue(new UnreportTask(this));\n      };\n      Rejected.prototype.fail = function (context) {\n        this.reported = true;\n        emitRejection('unhandledRejection', this);\n        Promise.onFatalRejection(this, context === void 0 ? this.context : context);\n      };\n      function ReportTask(rejection, context) {\n        this.rejection = rejection;\n        this.context = context;\n      }\n      ReportTask.prototype.run = function () {\n        if (!this.rejection.handled && !this.rejection.reported) {\n          this.rejection.reported = true;\n          emitRejection('unhandledRejection', this.rejection) || Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n        }\n      };\n      function UnreportTask(rejection) {\n        this.rejection = rejection;\n      }\n      UnreportTask.prototype.run = function () {\n        if (this.rejection.reported) {\n          emitRejection('rejectionHandled', this.rejection) || Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n        }\n      };\n\n      // Unhandled rejection hooks\n      // By default, everything is a noop\n\n      Promise.createContext = Promise.enterContext = Promise.exitContext = Promise.onPotentiallyUnhandledRejection = Promise.onPotentiallyUnhandledRejectionHandled = Promise.onFatalRejection = noop;\n\n      // Errors and singletons\n\n      var foreverPendingHandler = new Handler();\n      var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n      function cycle() {\n        return new Rejected(new TypeError('Promise cycle'));\n      }\n\n      // Task runners\n\n      /**\n       * Run a single consumer\n       * @constructor\n       */\n      function ContinuationTask(continuation, handler) {\n        this.continuation = continuation;\n        this.handler = handler;\n      }\n      ContinuationTask.prototype.run = function () {\n        this.handler.join().when(this.continuation);\n      };\n\n      /**\n       * Run a queue of progress handlers\n       * @constructor\n       */\n      function ProgressTask(value, handler) {\n        this.handler = handler;\n        this.value = value;\n      }\n      ProgressTask.prototype.run = function () {\n        var q = this.handler.consumers;\n        if (q === void 0) {\n          return;\n        }\n        for (var c, i = 0; i < q.length; ++i) {\n          c = q[i];\n          runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n        }\n      };\n\n      /**\n       * Assimilate a thenable, sending it's value to resolver\n       * @param {function} then\n       * @param {object|function} thenable\n       * @param {object} resolver\n       * @constructor\n       */\n      function AssimilateTask(then, thenable, resolver) {\n        this._then = then;\n        this.thenable = thenable;\n        this.resolver = resolver;\n      }\n      AssimilateTask.prototype.run = function () {\n        var h = this.resolver;\n        tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n        function _resolve(x) {\n          h.resolve(x);\n        }\n        function _reject(x) {\n          h.reject(x);\n        }\n        function _notify(x) {\n          h.notify(x);\n        }\n      };\n      function tryAssimilate(then, thenable, resolve, reject, notify) {\n        try {\n          then.call(thenable, resolve, reject, notify);\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      /**\n       * Fold a handler value with z\n       * @constructor\n       */\n      function Fold(f, z, c, to) {\n        this.f = f;\n        this.z = z;\n        this.c = c;\n        this.to = to;\n        this.resolver = failIfRejected;\n        this.receiver = this;\n      }\n      Fold.prototype.fulfilled = function (x) {\n        this.f.call(this.c, this.z, x, this.to);\n      };\n      Fold.prototype.rejected = function (x) {\n        this.to.reject(x);\n      };\n      Fold.prototype.progress = function (x) {\n        this.to.notify(x);\n      };\n\n      // Other helpers\n\n      /**\n       * @param {*} x\n       * @returns {boolean} true iff x is a trusted Promise\n       */\n      function isPromise(x) {\n        return x instanceof Promise;\n      }\n\n      /**\n       * Test just enough to rule out primitives, in order to take faster\n       * paths in some code\n       * @param {*} x\n       * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n       */\n      function maybeThenable(x) {\n        return (typeof x === 'object' || typeof x === 'function') && x !== null;\n      }\n      function runContinuation1(f, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n        Promise.enterContext(h);\n        tryCatchReject(f, h.value, receiver, next);\n        Promise.exitContext();\n      }\n      function runContinuation3(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n        Promise.enterContext(h);\n        tryCatchReject3(f, x, h.value, receiver, next);\n        Promise.exitContext();\n      }\n\n      /**\n       * @deprecated\n       */\n      function runNotify(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.notify(x);\n        }\n        Promise.enterContext(h);\n        tryCatchReturn(f, x, receiver, next);\n        Promise.exitContext();\n      }\n      function tryCatch2(f, a, b) {\n        try {\n          return f(a, b);\n        } catch (e) {\n          return reject(e);\n        }\n      }\n\n      /**\n       * Return f.call(thisArg, x), or if it throws return a rejected promise for\n       * the thrown exception\n       */\n      function tryCatchReject(f, x, thisArg, next) {\n        try {\n          next.become(getHandler(f.call(thisArg, x)));\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n\n      /**\n       * Same as above, but includes the extra argument parameter.\n       */\n      function tryCatchReject3(f, x, y, thisArg, next) {\n        try {\n          f.call(thisArg, x, y, next);\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n\n      /**\n       * @deprecated\n       * Return f.call(thisArg, x), or if it throws, *return* the exception\n       */\n      function tryCatchReturn(f, x, thisArg, next) {\n        try {\n          next.notify(f.call(thisArg, x));\n        } catch (e) {\n          next.notify(e);\n        }\n      }\n      function inherit(Parent, Child) {\n        Child.prototype = objectCreate(Parent.prototype);\n        Child.prototype.constructor = Child;\n      }\n      function snd(x, y) {\n        return y;\n      }\n      function noop() {}\n      function hasCustomEvent() {\n        if (typeof CustomEvent === 'function') {\n          try {\n            var ev = new CustomEvent('unhandledRejection');\n            return ev instanceof CustomEvent;\n          } catch (ignoredException) {}\n        }\n        return false;\n      }\n      function hasInternetExplorerCustomEvent() {\n        if (typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n          try {\n            // Try to create one event to make sure it's supported\n            var ev = document.createEvent('CustomEvent');\n            ev.initCustomEvent('eventType', false, true, {});\n            return true;\n          } catch (ignoredException) {}\n        }\n        return false;\n      }\n      function initEmitRejection() {\n        /*global process, self, CustomEvent*/\n        if (typeof process !== 'undefined' && process !== null && typeof process.emit === 'function') {\n          // Returning falsy here means to call the default\n          // onPotentiallyUnhandledRejection API.  This is safe even in\n          // browserify since process.emit always returns falsy in browserify:\n          // https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n          return function (type, rejection) {\n            return type === 'unhandledRejection' ? process.emit(type, rejection.value, rejection) : process.emit(type, rejection);\n          };\n        } else if (typeof self !== 'undefined' && hasCustomEvent()) {\n          return function (self, CustomEvent) {\n            return function (type, rejection) {\n              var ev = new CustomEvent(type, {\n                detail: {\n                  reason: rejection.value,\n                  key: rejection\n                },\n                bubbles: false,\n                cancelable: true\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, CustomEvent);\n        } else if (typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n          return function (self, document) {\n            return function (type, rejection) {\n              var ev = document.createEvent('CustomEvent');\n              ev.initCustomEvent(type, false, true, {\n                reason: rejection.value,\n                key: rejection\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, document);\n        }\n        return noop;\n      }\n      return Promise;\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"names":["define","makePromise","environment","tasks","scheduler","emitRejection","initEmitRejection","objectCreate","Object","create","proto","Child","prototype","Promise","resolver","handler","_handler","Handler","init","Pending","promiseResolve","promiseReject","promiseNotify","e","x","resolve","reason","reject","notify","never","_defer","defer","getHandler","isPromise","Async","Rejected","foreverPendingPromise","then","onFulfilled","onRejected","onProgress","parent","state","join","constructor","p","_beget","child","chain","receiver","begetFrom","context","all","race","_traverse","traverse","promises","traverseWith","snd","f","tryCatch2","tryMap","mapAt","settleAt","pending","length","results","Array","i","resolved","traverseAt","become","Fulfilled","maybeThenable","h","getHandlerMaybeThenable","s","fold","value","visitRemaining","_visitRemaining","start","markAsHandled","visit","_unreport","TypeError","runRace","getHandlerUntrusted","untrustedThen","Thenable","when","fail","_report","noop","_state","to","fulfilled","rejected","progress","failIfRejected","z","c","Fold","FailIfRejected","inherit","inheritedContext","createContext","consumers","cycle","run","q","enqueue","continuation","ContinuationTask","push","ProgressTask","thenable","call","AssimilateTask","runContinuation3","cont","runContinuation1","errorId","id","handled","reported","afterQueue","ReportTask","UnreportTask","onFatalRejection","rejection","onPotentiallyUnhandledRejection","onPotentiallyUnhandledRejectionHandled","enterContext","exitContext","foreverPendingHandler","runNotify","_then","tryAssimilate","_resolve","_reject","_notify","next","tryCatchReject","tryCatchReject3","tryCatchReturn","a","b","thisArg","y","Parent","hasCustomEvent","CustomEvent","ev","ignoredException","hasInternetExplorerCustomEvent","document","createEvent","initCustomEvent","process","emit","type","self","detail","key","bubbles","cancelable","dispatchEvent","amd","factory","module","exports"],"sources":["/Users/lucas/Desktop/Coding/Digital_House/Bimestre_4/clonado_2/grupo-04/node_modules/when/lib/makePromise.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction hasCustomEvent() {\n\t\t\tif(typeof CustomEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\treturn ev instanceof CustomEvent;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction hasInternetExplorerCustomEvent() {\n\t\t\tif(typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\t// Try to create one event to make sure it's supported\n\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\tev.initCustomEvent('eventType', false, true, {});\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && hasCustomEvent()) {\n\t\t\t\treturn (function (self, CustomEvent) {\n\t\t\t\t\treturn function (type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, CustomEvent));\n\t\t\t} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n\t\t\t\treturn (function(self, document) {\n\t\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\t\tev.initCustomEvent(type, false, true, {\n\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, document));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}