{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var state = require('../state');\n    var applier = require('../apply');\n    return function array(Promise) {\n      var applyFold = applier(Promise);\n      var toPromise = Promise.resolve;\n      var all = Promise.all;\n      var ar = Array.prototype.reduce;\n      var arr = Array.prototype.reduceRight;\n      var slice = Array.prototype.slice;\n\n      // Additional array combinators\n\n      Promise.any = any;\n      Promise.some = some;\n      Promise.settle = settle;\n      Promise.map = map;\n      Promise.filter = filter;\n      Promise.reduce = reduce;\n      Promise.reduceRight = reduceRight;\n\n      /**\n       * When this promise fulfills with an array, do\n       * onFulfilled.apply(void 0, array)\n       * @param {function} onFulfilled function to apply\n       * @returns {Promise} promise for the result of applying onFulfilled\n       */\n      Promise.prototype.spread = function (onFulfilled) {\n        return this.then(all).then(function (array) {\n          return onFulfilled.apply(this, array);\n        });\n      };\n      return Promise;\n\n      /**\n       * One-winner competitive race.\n       * Return a promise that will fulfill when one of the promises\n       * in the input array fulfills, or will reject when all promises\n       * have rejected.\n       * @param {array} promises\n       * @returns {Promise} promise for the first fulfilled value\n       */\n      function any(promises) {\n        var p = Promise._defer();\n        var resolver = p._handler;\n        var l = promises.length >>> 0;\n        var pending = l;\n        var errors = [];\n        for (var h, x, i = 0; i < l; ++i) {\n          x = promises[i];\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n          h = Promise._handler(x);\n          if (h.state() > 0) {\n            resolver.become(h);\n            Promise._visitRemaining(promises, i, h);\n            break;\n          } else {\n            h.visit(resolver, handleFulfill, handleReject);\n          }\n        }\n        if (pending === 0) {\n          resolver.reject(new RangeError('any(): array must not be empty'));\n        }\n        return p;\n        function handleFulfill(x) {\n          /*jshint validthis:true*/\n          errors = null;\n          this.resolve(x); // this === resolver\n        }\n\n        function handleReject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n          errors.push(e);\n          if (--pending === 0) {\n            this.reject(errors);\n          }\n        }\n      }\n\n      /**\n       * N-winner competitive race\n       * Return a promise that will fulfill when n input promises have\n       * fulfilled, or will reject when it becomes impossible for n\n       * input promises to fulfill (ie when promises.length - n + 1\n       * have rejected)\n       * @param {array} promises\n       * @param {number} n\n       * @returns {Promise} promise for the earliest n fulfillment values\n       *\n       * @deprecated\n       */\n      function some(promises, n) {\n        /*jshint maxcomplexity:7*/\n        var p = Promise._defer();\n        var resolver = p._handler;\n        var results = [];\n        var errors = [];\n        var l = promises.length >>> 0;\n        var nFulfill = 0;\n        var nReject;\n        var x, i; // reused in both for() loops\n\n        // First pass: count actual array items\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n          ++nFulfill;\n        }\n\n        // Compute actual goals\n        n = Math.max(n, 0);\n        nReject = nFulfill - n + 1;\n        nFulfill = Math.min(n, nFulfill);\n        if (n > nFulfill) {\n          resolver.reject(new RangeError('some(): array must contain at least ' + n + ' item(s), but had ' + nFulfill));\n        } else if (nFulfill === 0) {\n          resolver.resolve(results);\n        }\n\n        // Second pass: observe each array item, make progress toward goals\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n          Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n        }\n        return p;\n        function fulfill(x) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n          results.push(x);\n          if (--nFulfill === 0) {\n            errors = null;\n            this.resolve(results);\n          }\n        }\n        function reject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n          errors.push(e);\n          if (--nReject === 0) {\n            results = null;\n            this.reject(errors);\n          }\n        }\n      }\n\n      /**\n       * Apply f to the value of each promise in a list of promises\n       * and return a new list containing the results.\n       * @param {array} promises\n       * @param {function(x:*, index:Number):*} f mapping function\n       * @returns {Promise}\n       */\n      function map(promises, f) {\n        return Promise._traverse(f, promises);\n      }\n\n      /**\n       * Filter the provided array of promises using the provided predicate.  Input may\n       * contain promises and values\n       * @param {Array} promises array of promises and values\n       * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n       *  Must return truthy (or promise for truthy) for items to retain.\n       * @returns {Promise} promise that will fulfill with an array containing all items\n       *  for which predicate returned truthy.\n       */\n      function filter(promises, predicate) {\n        var a = slice.call(promises);\n        return Promise._traverse(predicate, a).then(function (keep) {\n          return filterSync(a, keep);\n        });\n      }\n      function filterSync(promises, keep) {\n        // Safe because we know all promises have fulfilled if we've made it this far\n        var l = keep.length;\n        var filtered = new Array(l);\n        for (var i = 0, j = 0; i < l; ++i) {\n          if (keep[i]) {\n            filtered[j++] = Promise._handler(promises[i]).value;\n          }\n        }\n        filtered.length = j;\n        return filtered;\n      }\n\n      /**\n       * Return a promise that will always fulfill with an array containing\n       * the outcome states of all input promises.  The returned promise\n       * will never reject.\n       * @param {Array} promises\n       * @returns {Promise} promise for array of settled state descriptors\n       */\n      function settle(promises) {\n        return all(promises.map(settleOne));\n      }\n      function settleOne(p) {\n        // Optimize the case where we get an already-resolved when.js promise\n        //  by extracting its state:\n        var handler;\n        if (p instanceof Promise) {\n          // This is our own Promise type and we can reach its handler internals:\n          handler = p._handler.join();\n        }\n        if (handler && handler.state() === 0 || !handler) {\n          // Either still pending, or not a Promise at all:\n          return toPromise(p).then(state.fulfilled, state.rejected);\n        }\n\n        // The promise is our own, but it is already resolved. Take a shortcut.\n        // Since we're not actually handling the resolution, we need to disable\n        // rejection reporting.\n        handler._unreport();\n        return state.inspect(handler);\n      }\n\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n      function reduce(promises, f /*, initialValue */) {\n        return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2]) : ar.call(promises, liftCombine(f));\n      }\n\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n      function reduceRight(promises, f /*, initialValue */) {\n        return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2]) : arr.call(promises, liftCombine(f));\n      }\n      function liftCombine(f) {\n        return function (z, x, i) {\n          return applyFold(f, void 0, [z, x, i]);\n        };\n      }\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"names":["define","require","state","applier","array","Promise","applyFold","toPromise","resolve","all","ar","Array","prototype","reduce","arr","reduceRight","slice","any","some","settle","map","filter","spread","onFulfilled","then","apply","promises","p","_defer","resolver","_handler","l","length","pending","errors","h","x","i","become","_visitRemaining","visit","handleFulfill","handleReject","reject","RangeError","e","resolved","push","n","results","nFulfill","nReject","Math","max","min","fulfill","notify","f","_traverse","predicate","a","call","keep","filterSync","filtered","j","value","settleOne","handler","join","fulfilled","rejected","_unreport","inspect","arguments","liftCombine","z","amd","factory","module","exports"],"sources":["/Users/lucas/Desktop/Coding/Digital_House/Bimestre_4/clonado_2/grupo-04/node_modules/when/lib/decorators/array.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\t// Optimize the case where we get an already-resolved when.js promise\n\t\t\t//  by extracting its state:\n\t\t\tvar handler;\n\t\t\tif (p instanceof Promise) {\n\t\t\t\t// This is our own Promise type and we can reach its handler internals:\n\t\t\t\thandler = p._handler.join();\n\t\t\t}\n\t\t\tif((handler && handler.state() === 0) || !handler) {\n\t\t\t\t// Either still pending, or not a Promise at all:\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\t// The promise is our own, but it is already resolved. Take a shortcut.\n\t\t\t// Since we're not actually handling the resolution, we need to disable\n\t\t\t// rejection reporting.\n\t\t\thandler._unreport();\n\t\t\treturn state.inspect(handler);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}